<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chamalnquimyst - Micro-Universo de Contenido</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Lato:wght@300;400&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS3DRenderer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/BoxLineGeometry.js"></script>

    <style>
        :root {
            --primary-glow-color: #4DDBFF;
            --secondary-glow-color: #0077FF;
            --text-color: #EAEAEA;
            --background-color: #02040a;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: 'Lato', sans-serif;
            cursor: default;
        }
        #webgl-container, #css-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #css-container {
            pointer-events: none;
        }
        #css-container > div {
            pointer-events: auto;
        }
        #blocker {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0);
            pointer-events: none;
            z-index: 10;
        }
        #instructions {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9em;
            z-index: 100;
            pointer-events: none;
            opacity: 1;
            transition: opacity 1s ease-out 5s;
        }
        
        .content-panel-wrapper {
            transition: transform 0.5s ease-out, box-shadow 0.3s ease;
            box-sizing: border-box;
        }
        .content-panel-wrapper.selected {
            box-shadow: 0 0 45px var(--primary-glow-color) !important;
        }

        .text-panel {
            background: rgba(2, 4, 10, 0.7);
            border: 5px solid;
            box-shadow: 0 0 30px;
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }
        .text-panel-title {
            font-family: 'Cinzel', serif;
            text-align: center;
            padding: 20px;
            font-size: 80px;
            flex-shrink: 0;
        }
        .text-panel-content {
            padding: 0 40px 40px 40px;
            font-size: 32px;
            flex-grow: 1;
            overflow-y: auto;
        }
        .text-panel-content::-webkit-scrollbar { width: 12px; }
        .text-panel-content::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); }
        .text-panel-content::-webkit-scrollbar-thumb {
            background-color: var(--primary-glow-color);
            border-radius: 20px;
            border: 3px solid transparent;
            background-clip: content-box;
        }
        .video-panel, .web-panel {
            width: 1280px;
            height: 720px;
            border: 5px solid rgba(77, 219, 255, 0.5);
            box-shadow: 0 0 30px rgba(77, 219, 255, 0.7);
            background-color: #000;
        }
        .video-panel iframe, .video-panel video, .web-panel iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        .pdf-panel {
            width: 800px;
            height: 1131px;
            border: 5px solid rgba(77, 219, 255, 0.5);
            box-shadow: 0 0 30px rgba(77, 219, 255, 0.7);
            background-color: #333;
            overflow-y: scroll !important;
        }
        .pdf-panel iframe, .pdf-panel embed {
            width: 100%;
            height: 100%;
            border: none;
        }
        .ui-button {
            position: fixed;
            width: 60px;
            height: 60px;
            background-color: var(--primary-glow-color);
            color: var(--background-color);
            border: none;
            border-radius: 50%;
            font-size: 36px;
            line-height: 60px;
            text-align: center;
            cursor: pointer;
            z-index: 200;
            box-shadow: 0 0 20px var(--primary-glow-color);
            transition: transform 0.3s ease, background-color 0.3s ease, opacity 1s ease;
            opacity: 1;
        }
        .ui-button.faded {
            opacity: 0.1;
        }
        .ui-button:hover {
            transform: scale(1.1);
            background-color: #fff;
            opacity: 1 !important;
        }
        #add-panel-btn {
            top: 30px;
            right: 30px;
        }
        #add-panel-btn:hover {
            transform: scale(1.1) rotate(90deg);
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 300;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .modal.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .modal-content {
            background: var(--background-color);
            border: 1px solid var(--primary-glow-color);
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 0 30px var(--secondary-glow-color);
        }
        .modal-content h3 {
            font-family: 'Cinzel', serif;
            color: var(--primary-glow-color);
            margin-top: 0;
            text-align: center;
        }
        .tab-buttons {
            display: flex;
            border-bottom: 1px solid var(--primary-glow-color);
            margin-bottom: 20px;
        }
        .tab-button {
            background: none;
            border: none;
            color: var(--text-color);
            padding: 10px 15px;
            cursor: pointer;
            font-size: 1em;
            opacity: 0.6;
            border-bottom: 3px solid transparent;
        }
        .tab-button.active {
            opacity: 1;
            border-bottom-color: var(--primary-glow-color);
        }
        .form-section { display: none; }
        .form-section.active { display: block; }
        .modal-content input, .modal-content textarea, .modal-content select {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            background: rgba(255,255,255,0.1);
            border: 1px solid var(--primary-glow-color);
            color: var(--text-color);
            border-radius: 5px;
            box-sizing: border-box;
        }
        .modal-content textarea {
            height: 120px;
            resize: vertical;
        }
        .modal-actions {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        .modal-actions button {
            background: var(--primary-glow-color);
            color: var(--background-color);
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        .modal-actions button.cancel {
            background: transparent;
            border: 1px solid var(--primary-glow-color);
            color: var(--primary-glow-color);
        }
        .file-upload-label {
            display: block;
            padding: 20px;
            border: 2px dashed var(--primary-glow-color);
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            margin-bottom: 15px;
        }
        .file-upload-label:hover {
            background: rgba(77, 219, 255, 0.1);
        }
        .file-preview {
            max-width: 100%;
            max-height: 150px;
            margin-top: 10px;
            border-radius: 5px;
        }
        .io-buttons {
            display: flex;
            gap: 10px;
        }
        .io-buttons button {
            font-size: 18px;
            padding: 8px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid var(--primary-glow-color);
            color: var(--primary-glow-color);
            transition: all 0.2s;
        }
        .io-buttons button:hover {
            background: var(--primary-glow-color);
            color: var(--background-color);
            transform: scale(1.1);
        }
        .layout-selector, .color-selector {
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .layout-selector label {
            cursor: pointer;
        }
        input[type="color"] {
            -webkit-appearance: none;
            width: 40px;
            height: 40px;
            border: none;
            cursor: pointer;
            background: none;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: 2px solid var(--primary-glow-color);
            border-radius: 50%;
        }
        .dynamic-input-group {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
        }
        .dynamic-input-group input {
            margin-bottom: 0;
        }
        .small-btn {
            padding: 5px 10px !important;
            height: 38px;
            margin-top: 0;
        }
        .add-more-btn {
            background: transparent !important;
            border: 1px dashed var(--primary-glow-color) !important;
            color: var(--primary-glow-color) !important;
            width: 100%;
            margin-top: 10px;
        }
        .add-more-btn:hover {
            background: rgba(77, 219, 255, 0.1) !important;
        }
        #autosave-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 12px;
            color: var(--primary-glow-color);
            opacity: 0;
            transition: opacity 0.5s;
        }
        #autosave-indicator.visible {
            opacity: 1;
        }

        /* ============================================= */
        /* ESTILOS PARA JOYSTICKS TÁCTILES              */
        /* ============================================= */
        .joystick-container {
            position: fixed;
            bottom: 30px;
            width: 140px;
            height: 140px;
            z-index: 500;
            touch-action: none;
            pointer-events: auto;
        }
        
        #joystick-left {
            left: 30px;
        }
        
        #joystick-right {
            right: 30px;
        }
        
        .joystick-base {
            position: absolute;
            width: 140px;
            height: 140px;
            background: radial-gradient(circle at center, 
                rgba(77, 219, 255, 0.15) 0%, 
                rgba(77, 219, 255, 0.05) 60%, 
                rgba(0, 119, 255, 0.1) 100%);
            border: 2px solid rgba(77, 219, 255, 0.4);
            border-radius: 50%;
            box-shadow: 
                0 0 20px rgba(77, 219, 255, 0.3),
                inset 0 0 30px rgba(0, 0, 0, 0.3);
        }
        
        .joystick-stick {
            position: absolute;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle at 30% 30%, 
                rgba(77, 219, 255, 0.9) 0%, 
                rgba(0, 119, 255, 0.7) 50%, 
                rgba(0, 50, 100, 0.8) 100%);
            border: 2px solid rgba(77, 219, 255, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 
                0 0 15px rgba(77, 219, 255, 0.6),
                0 4px 8px rgba(0, 0, 0, 0.4);
            transition: box-shadow 0.1s ease;
        }
        
        .joystick-stick.active {
            box-shadow: 
                0 0 25px rgba(77, 219, 255, 0.9),
                0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .joystick-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: rgba(77, 219, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
            white-space: nowrap;
        }
        
        .joystick-indicators {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .joystick-indicator {
            position: absolute;
            font-size: 10px;
            color: rgba(77, 219, 255, 0.5);
        }
        
        .joystick-indicator.top { top: 8px; left: 50%; transform: translateX(-50%); }
        .joystick-indicator.bottom { bottom: 8px; left: 50%; transform: translateX(-50%); }
        .joystick-indicator.left { left: 8px; top: 50%; transform: translateY(-50%); }
        .joystick-indicator.right { right: 8px; top: 50%; transform: translateY(-50%); }

        @media (hover: hover) and (pointer: fine) {
            .joystick-container {
                display: none;
            }
        }
        
        @media (hover: none) and (pointer: coarse) {
            .joystick-container {
                display: block;
            }
            #instructions {
                bottom: 180px;
            }
        }
    </style>
</head>
<body>
    <div id="webgl-container"></div>
    <div id="css-container"></div>
    <div id="blocker"></div>
    <div id="instructions">
        Usa [W,A,S,D] para moverte, [Z,X] para subir/bajar, [Q,E] y [Ratón] para girar. 
        [Doble Click] para Enfocar/Entrar. [Supr] para borrar. [Flechas] para navegar en zoom.
    </div>
    
    <div id="autosave-indicator">Guardado automático...</div>
    <input type="file" id="folder-input" webkitdirectory directory multiple style="display:none">
    <button id="add-panel-btn" class="ui-button">+</button>

    <!-- JOYSTICKS TÁCTILES -->
    <div id="joystick-left" class="joystick-container">
        <div class="joystick-base">
            <div class="joystick-indicators">
                <span class="joystick-indicator top">▲</span>
                <span class="joystick-indicator bottom">▼</span>
                <span class="joystick-indicator left">◄</span>
                <span class="joystick-indicator right">►</span>
            </div>
        </div>
        <div class="joystick-stick" id="stick-left"></div>
        <div class="joystick-label">Mover</div>
    </div>
    
    <div id="joystick-right" class="joystick-container">
        <div class="joystick-base">
            <div class="joystick-indicators">
                <span class="joystick-indicator top">↑</span>
                <span class="joystick-indicator bottom">↓</span>
                <span class="joystick-indicator left">↶</span>
                <span class="joystick-indicator right">↷</span>
            </div>
        </div>
        <div class="joystick-stick" id="stick-right"></div>
        <div class="joystick-label">Cámara</div>
    </div>

    <div id="creation-modal" class="modal">
        <div class="modal-content">
            <h3 id="modal-title">Crear Nuevo Panel</h3>
            <div class="tab-buttons">
                <button class="tab-button active" data-type="text">Texto</button>
                <button class="tab-button" data-type="video">Video</button>
                <button class="tab-button" data-type="web">Web</button>
                <button class="tab-button" data-type="file">Archivo</button>
                <button class="tab-button" data-type="360">360°/VR</button>
            </div>
            
            <div id="text-form" class="form-section active">
                <input type="text" id="text-title" placeholder="Título...">
                <textarea id="text-content" placeholder="Contenido..."></textarea>
                <div class="color-selector">
                    <label for="text-color-picker">Color del Marco:</label>
                    <input type="color" id="text-color-picker" value="#4DDBFF">
                </div>
            </div>
            
            <div id="video-form" class="form-section">
                <div id="video-inputs-container">
                    <div class="dynamic-input-group">
                        <input type="text" class="video-url-input" placeholder="URL de YouTube...">
                    </div>
                </div>
                <button type="button" id="add-video-input-btn" class="add-more-btn">+ Agregar otro video</button>
            </div>
            
            <div id="web-form" class="form-section">
                <div id="web-inputs-container">
                    <div class="dynamic-input-group">
                        <input type="text" class="web-url-input" placeholder="URL de la página web...">
                    </div>
                </div>
                <button type="button" id="add-web-input-btn" class="add-more-btn">+ Agregar otra web</button>
            </div>
            
            <div id="file-form" class="form-section">
                <input type="file" id="file-upload" accept="image/*,video/mp4,video/avi,application/pdf,.txt,.md,text/html" style="display: none;" multiple>
                <label for="file-upload" class="file-upload-label">
                    Haz clic para seleccionar archivos
                    <img id="image-preview" class="file-preview" src="" alt="Vista previa" style="display:none;">
                </label>
                <div class="layout-selector">
                    <strong>Disposición:</strong>
                    <label><input type="radio" name="layout" value="sphere" checked> Esfera</label>
                    <label><input type="radio" name="layout" value="cylinder"> Cilindro</label>
                    <label><input type="radio" name="layout" value="fibonacci"> Fibonacci</label>
                </div>
            </div>
            
            <div id="360-form" class="form-section">
                <select id="360-type">
                    <option value="upload">Subir Video 360</option>
                    <option value="youtube">YouTube 360</option>
                    <option value="stream">Stream Cámara IP (Wifi)</option>
                </select>
                <div id="360-upload-div" style="margin-top:10px;">
                    <input type="file" id="video-360-input" accept="video/*">
                </div>
                <div id="360-youtube-div" style="display:none; margin-top:10px;">
                    <input type="text" id="youtube-360-url" placeholder="URL de YouTube 360...">
                    <p style="font-size:10px; color:#aaa">Nota: Se proyectará en una esfera inmersiva.</p>
                </div>
                <div id="360-stream-div" style="display:none; margin-top:10px;">
                    <input type="text" id="stream-url" placeholder="http://192.168.x.x:8080/video">
                    <p style="font-size:10px; color:#aaa">Nota: Requiere una URL de stream compatible (MJPEG/HLS)</p>
                </div>
            </div>

            <div class="modal-actions">
                <div class="io-buttons">
                     <button id="save-scene-btn" title="Guardar Escena">&#x1F4BE;</button>
                     <button id="load-scene-btn" title="Cargar Escena">&#x1F4C2;</button>
                     <button id="scan-folder-btn" title="Escanear USB/Carpeta">&#x1F50D;</button>
                     <input type="file" id="load-file-input" style="display: none;" accept=".json">
                </div>
                <div>
                    <button id="cancel-creation-btn" class="cancel">Cancelar</button>
                    <button id="create-panel-btn">Crear</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- SETUP BÁSICO ---
        let scene, camera, webglRenderer, cssRenderer, clock;
        let avatarObject;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, moveUp = false, moveDown = false;
        let rotateLeft = false, rotateRight = false;
        
        let isCameraDragging = false;
        let isObjectDragging = false;
        let draggedObject = null;
        let dragPlane, offset = new THREE.Vector3();
        let previousMousePosition = { x: 0, y: 0 };
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        let yawAngle = 0, pitchAngle = 0;
        const mouseSensitivity = 0.002;
        const cameraRotationSpeed = 0.02;
        let initialFov;
        let zoomDistance = 25;
        
        let contentPanels = [];
        let draggableObjects = [];
        const blocker = document.getElementById('blocker');
        let lastClickTime = 0;
        let editingPanel = null;
        let selectedObject = null;
        let viewMode = 'lookAtCamera';

        let isFocused = false;
        let isTransitioning = false;
        let focusedObject = null;
        let lastCameraPosition = new THREE.Vector3();
        let lastCameraQuaternion = new THREE.Quaternion();

        let btnIdleTimer;
        const MAX_ACTIVE_VIDEOS = 3;
        const THUMBNAIL_DISTANCE = 1200;
        const PLAY_DISTANCE = 100;
        
        let videoPanels = [];
        let thumbnailQueue = [];
        let isProcessingThumbnail = false;

        // VARIABLES PARA JOYSTICKS TÁCTILES
        let joystickLeftActive = false;
        let joystickRightActive = false;
        let joystickLeftTouchId = null;
        let joystickRightTouchId = null;
        let joystickLeftValue = { x: 0, y: 0 };
        let joystickRightValue = { x: 0, y: 0 };

        init();
        animate();
        startAutoSave(); 

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x02040a, 50, 300);
            clock = new THREE.Clock();

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            initialFov = camera.fov;
            const avatarGeometry = new THREE.SphereGeometry(0.1, 16, 12);
            const avatarMaterial = new THREE.MeshBasicMaterial({ visible: false });
            avatarObject = new THREE.Mesh(avatarGeometry, avatarMaterial);
            avatarObject.position.set(0, 0, 0);
            scene.add(avatarObject);
            
            webglRenderer = new THREE.WebGLRenderer({ antialias: true });
            webglRenderer.setPixelRatio(window.devicePixelRatio);
            webglRenderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('webgl-container').appendChild(webglRenderer.domElement);

            cssRenderer = new THREE.CSS3DRenderer();
            cssRenderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('css-container').appendChild(cssRenderer.domElement);
            
            dragPlane = new THREE.Plane();
            
            const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xADD8E6, 0.8);
            directionalLight.position.set(-1, 1, 1);
            scene.add(directionalLight);

            const starCount = 5000;
            const starGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount; i++) {
                positions[i * 3 + 0] = (Math.random() - 0.5) * 500;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 500;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 500;
            }
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starMaterial = new THREE.PointsMaterial({ color: 0xAAAAAA, size: 0.15 });
            const starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
            
            loadDefaultScene();
            initEventListeners();
            initJoysticks();
            resetBtnIdleTimer(); 
            setInterval(processThumbnailQueue, 500);
        }

        function loadDefaultScene() {
            const initialSceneData = [
                { type: 'text', title: 'El Viaje del Héroe', content: 'Cada concepto es una etapa en el viaje. El Chamán nos arraiga en la tierra. La Alquimia nos enseña a navegar las aguas de la emoción y el intelecto. El Misterio nos invita a mirar hacia las estrellas, reconociendo la unidad en la diversidad.', position: [-15, 2, 0], color: '#4DDBFF' },
                { type: 'image', src: 'https://placehold.co/1024x768/02040a/FF6B4D?text=Conciencia+Salvaje', position: [0, 5, -15], color: '#FF6B4D' },
                { type: 'video', videoId: '47Korua-WLo', start: 311, position: [15, 0, 0] }
            ];
            buildSceneFromData(initialSceneData);
        }

        function resetBtnIdleTimer() {
            const btn = document.getElementById('add-panel-btn');
            btn.classList.remove('faded');
            clearTimeout(btnIdleTimer);
            btnIdleTimer = setTimeout(() => {
                btn.classList.add('faded');
            }, 5000);
        }

        // INICIALIZACIÓN DE JOYSTICKS TÁCTILES
        function initJoysticks() {
            const joystickLeft = document.getElementById('joystick-left');
            const joystickRight = document.getElementById('joystick-right');

            joystickLeft.addEventListener('touchstart', (e) => handleJoystickStart(e, 'left'), { passive: false });
            joystickLeft.addEventListener('touchmove', (e) => handleJoystickMove(e, 'left'), { passive: false });
            joystickLeft.addEventListener('touchend', (e) => handleJoystickEnd(e, 'left'), { passive: false });
            joystickLeft.addEventListener('touchcancel', (e) => handleJoystickEnd(e, 'left'), { passive: false });

            joystickRight.addEventListener('touchstart', (e) => handleJoystickStart(e, 'right'), { passive: false });
            joystickRight.addEventListener('touchmove', (e) => handleJoystickMove(e, 'right'), { passive: false });
            joystickRight.addEventListener('touchend', (e) => handleJoystickEnd(e, 'right'), { passive: false });
            joystickRight.addEventListener('touchcancel', (e) => handleJoystickEnd(e, 'right'), { passive: false });

            joystickLeft.addEventListener('mousedown', (e) => handleJoystickMouseStart(e, 'left'));
            joystickRight.addEventListener('mousedown', (e) => handleJoystickMouseStart(e, 'right'));
            document.addEventListener('mousemove', handleJoystickMouseMove);
            document.addEventListener('mouseup', handleJoystickMouseEnd);
        }

        function handleJoystickStart(e, side) {
            e.preventDefault();
            const touch = e.changedTouches[0];
            const joystick = document.getElementById('joystick-' + side);
            const stick = document.getElementById('stick-' + side);
            const rect = joystick.getBoundingClientRect();
            
            if (side === 'left') {
                joystickLeftActive = true;
                joystickLeftTouchId = touch.identifier;
            } else {
                joystickRightActive = true;
                joystickRightTouchId = touch.identifier;
            }
            
            stick.classList.add('active');
            updateJoystickPosition(touch.clientX, touch.clientY, side, rect);
        }

        function handleJoystickMove(e, side) {
            e.preventDefault();
            const touchId = side === 'left' ? joystickLeftTouchId : joystickRightTouchId;
            const isActive = side === 'left' ? joystickLeftActive : joystickRightActive;
            
            if (!isActive) return;
            
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (touch.identifier === touchId) {
                    const joystick = document.getElementById('joystick-' + side);
                    const rect = joystick.getBoundingClientRect();
                    updateJoystickPosition(touch.clientX, touch.clientY, side, rect);
                    break;
                }
            }
        }

        function handleJoystickEnd(e, side) {
            e.preventDefault();
            const touchId = side === 'left' ? joystickLeftTouchId : joystickRightTouchId;
            
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === touchId) {
                    resetJoystick(side);
                    break;
                }
            }
        }

        function handleJoystickMouseStart(e, side) {
            e.preventDefault();
            const joystick = document.getElementById('joystick-' + side);
            const stick = document.getElementById('stick-' + side);
            const rect = joystick.getBoundingClientRect();
            
            if (side === 'left') {
                joystickLeftActive = true;
            } else {
                joystickRightActive = true;
            }
            
            stick.classList.add('active');
            updateJoystickPosition(e.clientX, e.clientY, side, rect);
        }

        function handleJoystickMouseMove(e) {
            if (joystickLeftActive) {
                const joystick = document.getElementById('joystick-left');
                const rect = joystick.getBoundingClientRect();
                updateJoystickPosition(e.clientX, e.clientY, 'left', rect);
            }
            if (joystickRightActive) {
                const joystick = document.getElementById('joystick-right');
                const rect = joystick.getBoundingClientRect();
                updateJoystickPosition(e.clientX, e.clientY, 'right', rect);
            }
        }

        function handleJoystickMouseEnd(e) {
            if (joystickLeftActive) resetJoystick('left');
            if (joystickRightActive) resetJoystick('right');
        }

        function updateJoystickPosition(clientX, clientY, side, rect) {
            const stick = document.getElementById('stick-' + side);
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const maxDistance = rect.width / 2 - 30;
            
            let deltaX = clientX - centerX;
            let deltaY = clientY - centerY;
            
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            if (distance > maxDistance) {
                deltaX = (deltaX / distance) * maxDistance;
                deltaY = (deltaY / distance) * maxDistance;
            }
            
            stick.style.transform = 'translate(calc(-50% + ' + deltaX + 'px), calc(-50% + ' + deltaY + 'px))';
            
            const normalizedX = deltaX / maxDistance;
            const normalizedY = deltaY / maxDistance;
            
            if (side === 'left') {
                joystickLeftValue = { x: normalizedX, y: normalizedY };
            } else {
                joystickRightValue = { x: normalizedX, y: normalizedY };
            }
        }

        function resetJoystick(side) {
            const stick = document.getElementById('stick-' + side);
            stick.style.transform = 'translate(-50%, -50%)';
            stick.classList.remove('active');
            
            if (side === 'left') {
                joystickLeftActive = false;
                joystickLeftTouchId = null;
                joystickLeftValue = { x: 0, y: 0 };
            } else {
                joystickRightActive = false;
                joystickRightTouchId = null;
                joystickRightValue = { x: 0, y: 0 };
            }
        }

        function initEventListeners() {
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('mousemove', (e) => {
                onMouseMove(e);
                resetBtnIdleTimer(); 
            });
            document.addEventListener('wheel', (e) => {
                onMouseWheel(e);
                resetBtnIdleTimer();
            });

            document.getElementById('add-panel-btn').addEventListener('click', openCreationModal);
            document.getElementById('save-scene-btn').addEventListener('click', saveSceneToFile);
            document.getElementById('load-scene-btn').addEventListener('click', () => document.getElementById('load-file-input').click());
            document.getElementById('load-file-input').addEventListener('change', loadSceneFromFile);
            
            document.getElementById('scan-folder-btn').addEventListener('click', () => document.getElementById('folder-input').click());

            const modal = document.getElementById('creation-modal');
            document.getElementById('cancel-creation-btn').addEventListener('click', () => modal.classList.remove('visible'));
            document.getElementById('create-panel-btn').addEventListener('click', handleCreateOrUpdatePanel);

            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', (e) => switchTab(e.target.dataset.type));
            });

            document.getElementById('add-video-input-btn').addEventListener('click', addVideoInputRow);
            document.getElementById('add-web-input-btn').addEventListener('click', addWebInputRow); 

            async function handleCreateOrUpdatePanel() {
                const activeTab = document.querySelector('.tab-button.active').dataset.type;
                // Calculamos una posición a 10 unidades frente a donde mira la cámara
                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                const pos = avatarObject.position.clone().add(dir.multiplyScalar(10));
                
                if (activeTab === 'text') {
                    const title = document.getElementById('text-title').value;
                    const content = document.getElementById('text-content').value;
                    const color = document.getElementById('text-color-picker').value;
                    addTextPanelToScene(title, content, pos, color);
                } 
                else if (activeTab === 'video') {
                    const inputs = document.querySelectorAll('.video-url-input');
                    inputs.forEach((input, i) => {
                        if (input.value) {
                            const videoId = parseYoutubeUrl(input.value);
                            if (videoId) {
                                const offsetPos = pos.clone().add(new THREE.Vector3(i * 15, 0, 0));
                                addVideoPanelToScene(videoId, 0, offsetPos);
                            }
                        }
                    });
                }
                else if (activeTab === 'web') {
                    const inputs = document.querySelectorAll('.web-url-input');
                    inputs.forEach((input, i) => {
                        if (input.value) {
                            const offsetPos = pos.clone().add(new THREE.Vector3(i * 15, 0, 0));
                            addWebPanelToScene(input.value, offsetPos);
                        }
                    });
                }
                else if (activeTab === 'file') {
                    const fileInput = document.getElementById('file-upload');
                    if (fileInput.files.length > 0) {
                        for (let i = 0; i < fileInput.files.length; i++) {
                            const offsetPos = pos.clone().add(new THREE.Vector3(i * 12, 0, 0));
                            await createPanelFromFile(fileInput.files[i], offsetPos);
                        }
                    }
                }

                document.getElementById('creation-modal').classList.remove('visible');
            }

            // Función auxiliar para extraer ID de YouTube
            function parseYoutubeUrl(url) {
                const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
                const match = url.match(regExp);
                return (match && match[2].length === 11) ? match[2] : null;
            }

            const fileUpload = document.getElementById('file-upload');
            const imagePreview = document.getElementById('image-preview');
            fileUpload.addEventListener('change', (e) => {
                if (e.target.files && e.target.files[0]) {
                    const file = e.target.files[0];
                    if (file.type.startsWith('image/')) {
                        imagePreview.src = URL.createObjectURL(file);
                        imagePreview.style.display = 'block';
                    } else {
                        imagePreview.style.display = 'none';
                    }
                }
            });

            document.getElementById('360-type').addEventListener('change', (e) => {
                document.getElementById('360-upload-div').style.display = e.target.value === 'upload' ? 'block' : 'none';
                document.getElementById('360-youtube-div').style.display = e.target.value === 'youtube' ? 'block' : 'none';
                document.getElementById('360-stream-div').style.display = e.target.value === 'stream' ? 'block' : 'none';
            });

            document.getElementById('folder-input').addEventListener('change', handleFolderScan);

            setTimeout(() => {
                document.getElementById('instructions').style.opacity = '0';
            }, 5000);
        }

        function startAutoSave() {
            setInterval(() => {
                const data = serializeScene();
                localStorage.setItem('autosave_scene', JSON.stringify(data));
                const indicator = document.getElementById('autosave-indicator');
                indicator.classList.add('visible');
                setTimeout(() => indicator.classList.remove('visible'), 2000);
            }, 30000); 
        }

        function serializeScene() {
            const sceneData = [];
            draggableObjects.forEach(obj => {
                const data = {
                    type: obj.userData.type,
                    position: obj.position.toArray()
                };
                if (obj.userData.type === 'text') {
                    data.title = obj.userData.title;
                    data.content = obj.userData.content;
                    data.color = obj.userData.color;
                } else if (obj.userData.type === 'image') {
                    data.src = obj.userData.src;
                    if(obj.children.length > 0 && obj.children[0].material) {
                         data.color = new THREE.Color(obj.children[0].material.color).getHexString();
                    }
                } else if (obj.userData.type === 'video') {
                    data.videoId = obj.userData.cssObject.userData.videoId;
                } else if (obj.userData.type === 'web') {
                    data.url = obj.userData.cssObject.userData.url;
                } else if (obj.userData.type === 'html') {
                    data.content = obj.userData.cssObject.userData.content;
                } else if (obj.userData.type === 'localVideo' || obj.userData.type === 'pdf') {
                    data.src = obj.userData.cssObject ? obj.userData.cssObject.userData.src : obj.userData.src; 
                } else if (obj.userData.type === '360') {
                    data.src = obj.userData.src;
                    data.isYouTube = obj.userData.isYouTube || false;
                }
                sceneData.push(data);
            });
            return sceneData;
        }

        function addVideoInputRow() {
            const container = document.getElementById('video-inputs-container');
            const div = document.createElement('div');
            div.className = 'dynamic-input-group';
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'video-url-input';
            input.placeholder = 'Otra URL de YouTube...';
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'modal-actions button cancel small-btn';
            btn.innerHTML = '✕';
            btn.style.borderColor = 'red';
            btn.style.color = 'red';
            btn.onclick = () => div.remove();
            div.appendChild(input);
            div.appendChild(btn);
            container.appendChild(div);
        }

        function addWebInputRow() {
            const container = document.getElementById('web-inputs-container');
            const div = document.createElement('div');
            div.className = 'dynamic-input-group';
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'web-url-input';
            input.placeholder = 'Otra URL web...';
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'modal-actions button cancel small-btn';
            btn.innerHTML = '✕';
            btn.style.borderColor = 'red';
            btn.style.color = 'red';
            btn.onclick = () => div.remove();
            div.appendChild(input);
            div.appendChild(btn);
            container.appendChild(div);
        }

        async function handleFolderScan(event) {
            const files = Array.from(event.target.files);
            if(files.length === 0) return;

            const validFiles = files.filter(f => {
                return f.name[0] !== '.' && (f.type.startsWith('image/') || f.type.startsWith('video/'));
            }).sort((a,b) => b.lastModified - a.lastModified);
            
            if (validFiles.length === 0) {
                alert("No se encontraron imágenes o videos válidos en la carpeta seleccionada.");
                return;
            }

            alert('Procesando ' + validFiles.length + ' archivos multimedia...');

            const goldenAngle = Math.PI * (3 - Math.sqrt(5)); 
            const spreadFactor = 12; 
            const zStep = 4; 

            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            dir.y = 0; dir.normalize();
            const startPos = avatarObject.position.clone();

            for(let i=0; i<validFiles.length; i++) {
                const file = validFiles[i];
                
                const r = spreadFactor * Math.sqrt(i + 1);
                const theta = i * goldenAngle;
                
                const localX = r * Math.cos(theta);
                const localY = r * Math.sin(theta);
                const localZ = -(i * zStep) - 20; 

                const pos = new THREE.Vector3(localX, localY, localZ);
                pos.applyAxisAngle(new THREE.Vector3(0,1,0), yawAngle);
                pos.add(startPos);

                await createPanelFromFile(file, pos);
            }
        }

        async function createPanelFromFile(file, pos) {
            const url = URL.createObjectURL(file);
            
            if (file.type.startsWith('image/')) {
                addImagePanelToScene(url, pos);
            } 
            else if (file.type.startsWith('video/')) {
                addLocalVideoPanelToScene(url, pos);
            } 
        }

        function updateVideoLOD() {
            if (videoPanels.length === 0) return;

            videoPanels.forEach(panel => {
                panel.distanceToCamera = panel.mesh.position.distanceTo(camera.position);
            });

            videoPanels.sort((a, b) => a.distanceToCamera - b.distanceToCamera);

            for (let i = 0; i < videoPanels.length; i++) {
                const panel = videoPanels[i];
                const shouldPlay = (i < MAX_ACTIVE_VIDEOS) && (panel.distanceToCamera < PLAY_DISTANCE);
                const shouldHaveThumbnail = (panel.distanceToCamera < THUMBNAIL_DISTANCE);

                if (shouldPlay) {
                    if (panel.status !== 'playing') {
                        activateVideoPanel(panel);
                    }
                } else {
                    if (panel.status === 'playing') {
                        deactivateVideoPanel(panel);
                    }
                    
                    if (shouldHaveThumbnail && !panel.textureLoaded && !panel.thumbnailLoading) {
                        if (!thumbnailQueue.includes(panel)) {
                            thumbnailQueue.push(panel);
                        }
                    }
                }
            }
        }

        function processThumbnailQueue() {
            if (isProcessingThumbnail || thumbnailQueue.length === 0) return;
            
            thumbnailQueue.sort((a, b) => a.distanceToCamera - b.distanceToCamera);
            
            const panel = thumbnailQueue.shift();
            if (panel.distanceToCamera > THUMBNAIL_DISTANCE) return; 

            generateThumbnail(panel);
        }

        function generateThumbnail(panel) {
            isProcessingThumbnail = true;
            panel.thumbnailLoading = true;

            const video = document.createElement('video');
            video.src = panel.src;
            video.crossOrigin = 'anonymous';
            video.muted = true;
            video.currentTime = 1.0;
            video.preload = 'metadata';

            const cleanup = () => {
                video.remove();
                isProcessingThumbnail = false;
                panel.thumbnailLoading = false;
            };

            const onSeeked = () => {
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = 512; 
                    canvas.height = 512 * (video.videoHeight / video.videoWidth) || 288;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                    const texture = new THREE.CanvasTexture(canvas);
                    panel.mesh.material.map = texture;
                    panel.mesh.material.color.setHex(0xffffff);
                    panel.mesh.material.needsUpdate = true;
                    panel.textureLoaded = true;
                } catch(e) { console.log("Error generando thumb", e); }
                cleanup();
            };

            video.addEventListener('loadeddata', () => {
                video.currentTime = 1.0;
            });
            video.addEventListener('seeked', onSeeked);
            video.addEventListener('error', cleanup);
            
            setTimeout(cleanup, 4000);

            video.load();
        }

        function activateVideoPanel(panel) {
            if (!panel.videoElement) {
                const video = document.createElement('video');
                video.src = panel.src;
                video.muted = true; 
                video.loop = true;
                video.autoplay = true;
                video.width = 1280;
                video.height = 720;
                video.style.pointerEvents = 'none';
                
                const div = document.createElement('div');
                div.className = 'video-panel';
                div.appendChild(video);
                
                const cssObject = new THREE.CSS3DObject(div);
                const scale = 0.015;
                cssObject.scale.set(scale, scale, scale);
                cssObject.position.copy(panel.mesh.position);
                cssObject.rotation.copy(panel.mesh.rotation);
                
                scene.add(cssObject);
                
                panel.videoElement = video;
                panel.cssObject = cssObject;
                panel.mesh.userData.cssObject = cssObject;
                panel.mesh.userData.contentElement = video; 
            }
            
            panel.videoElement.play().catch(e => {}); 
            panel.mesh.visible = false; 
            panel.status = 'playing';
        }

        function deactivateVideoPanel(panel) {
            if (panel.videoElement) {
                panel.videoElement.pause();
                if (panel.cssObject) {
                    scene.remove(panel.cssObject);
                }
                panel.videoElement = null;
                panel.cssObject = null;
                panel.mesh.userData.cssObject = null;
            }
            panel.mesh.visible = true; 
            panel.status = 'idle';
        }

        function addLocalVideoPanelToScene(src, position) {
            const geometry = new THREE.PlaneGeometry(10.24, 7.68);
            const material = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide }); 
            const proxyObject = new THREE.Mesh(geometry, material);
            proxyObject.position.copy(position);
            
            const borderGeo = new THREE.BoxLineGeometry(10.34, 7.78, 0.1, 1, 1, 1);
            const borderMat = new THREE.LineBasicMaterial({ color: 0xFF00FF, transparent: true, opacity: 0.8 });
            const border = new THREE.LineSegments(borderGeo, borderMat);
            proxyObject.add(border);

            proxyObject.userData = { 
                type: 'localVideo', 
                src: src, 
                velocity: new THREE.Vector3() 
            };

            scene.add(proxyObject);
            draggableObjects.push(proxyObject);
            contentPanels.push(proxyObject);

            videoPanels.push({
                mesh: proxyObject,
                src: src,
                status: 'idle',
                distanceToCamera: Infinity,
                textureLoaded: false,
                thumbnailLoading: false
            });
        }

        function create360Bubble(src, pos, isStream, isYouTube) {
            isStream = isStream || false;
            isYouTube = isYouTube || false;
            let mesh;
            if (isYouTube) {
                const videoId = parseYoutubeUrl(src);
                if(!videoId) return;
                const div = document.createElement('div');
                div.style.width = '1024px';
                div.style.height = '768px';
                const iframe = document.createElement('iframe');
                iframe.src = 'https://www.youtube.com/embed/' + videoId + '?autoplay=1&loop=1&playlist=' + videoId; 
                iframe.style.width = '100%';
                iframe.style.height = '100%';
                iframe.style.border = 'none';
                div.appendChild(iframe);
                const object = new THREE.CSS3DObject(div);
                object.position.copy(pos);
                object.scale.set(0.05, 0.05, 0.05); 
                const geom = new THREE.SphereGeometry(15, 16, 16);
                const mat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, opacity: 0.1, transparent: true });
                mesh = new THREE.Mesh(geom, mat);
                mesh.position.copy(pos);
                mesh.userData = { type: '360', cssObject: object, isYouTube: true, src: src };
                object.userData = { contentElement: iframe }; 
                scene.add(object);
            } else {
                const geom = new THREE.SphereGeometry(15, 60, 40);
                geom.scale(-1, 1, 1);
                const video = document.createElement('video');
                video.src = src;
                if(isStream) video.crossOrigin = "anonymous";
                video.loop = true; video.muted = true; video.play();
                const tex = new THREE.VideoTexture(video);
                const mat = new THREE.MeshBasicMaterial({map: tex});
                mesh = new THREE.Mesh(geom, mat);
                mesh.position.copy(pos);
                const border = new THREE.Mesh(new THREE.SphereGeometry(15.2, 32, 32), new THREE.MeshBasicMaterial({color:0x4DDBFF, wireframe:true, transparent:true, opacity:0.1}));
                mesh.add(border);
                mesh.scale.set(0.1, 0.1, 0.1); 
                mesh.userData = { type: '360', video: video, src: src };
            }
            scene.add(mesh);
            draggableObjects.push(mesh);
            contentPanels.push(mesh);
        }

        function openCreationModal() {
            editingPanel = null;
            document.getElementById('modal-title').textContent = "Crear Nuevo Panel";
            document.getElementById('create-panel-btn').textContent = "Crear";
            document.getElementById('text-title').value = "";
            document.getElementById('text-content').value = "";
            const vContainer = document.getElementById('video-inputs-container');
            vContainer.innerHTML = ''; 
            const vDiv = document.createElement('div'); vDiv.className = 'dynamic-input-group';
            const vInput = document.createElement('input'); vInput.type='text'; vInput.className='video-url-input'; vInput.placeholder='URL de YouTube...';
            vDiv.appendChild(vInput); vContainer.appendChild(vDiv);
            const wContainer = document.getElementById('web-inputs-container');
            wContainer.innerHTML = ''; 
            const wDiv = document.createElement('div'); wDiv.className = 'dynamic-input-group';
            const wInput = document.createElement('input'); wInput.type='text'; wInput.className='web-url-input'; wInput.placeholder='URL de la página web...';
            wDiv.appendChild(wInput); wContainer.appendChild(wDiv);
            document.getElementById('file-upload').value = "";
            document.getElementById('image-preview').style.display = 'none';
            document.getElementById('text-color-picker').value = "#4DDBFF";
            switchTab('text');
            document.getElementById('creation-modal').classList.add('visible');
        }

        function openEditModal(panel) {
            editingPanel = panel;
            document.getElementById('modal-title').textContent = "Editar Panel de Texto";
            document.getElementById('create-panel-btn').textContent = "Actualizar";
            document.getElementById('text-title').value = panel.userData.title;
            document.getElementById('text-content').value = panel.userData.content;
            document.getElementById('text-color-picker').value = panel.userData.color;
            switchTab('text');
            document.getElementById('creation-modal').classList.add('visible');
        }

        function switchTab(type) {
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelector('.tab-button[data-type="' + type + '"]').classList.add('active');
            document.querySelectorAll('.form-section').forEach(section => section.classList.remove('active'));
            document.getElementById(type + '-form').classList.add('active');
        }


        function createPdfPanel(src) {
            const div = document.createElement('div');
            div.className = 'content-panel-wrapper';
            const pdfWrapper = document.createElement('div');
            pdfWrapper.className = 'pdf-panel';
            const embed = document.createElement('embed');
            embed.src = src;
            embed.type = 'application/pdf';
            embed.style.pointerEvents = 'none';
            pdfWrapper.appendChild(embed);
            div.appendChild(pdfWrapper);
            const cssObject = new THREE.CSS3DObject(div);
            const scale = 0.01;
            cssObject.scale.set(scale, scale, scale);
            cssObject.userData = { type: 'pdf', src: src, contentElement: embed };
            const proxyGeometry = new THREE.PlaneGeometry(800 * scale, 1131 * scale);
            const proxyMaterial = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, side: THREE.DoubleSide });
            const proxyObject = new THREE.Mesh(proxyGeometry, proxyMaterial);
            proxyObject.userData.cssObject = cssObject;
            proxyObject.userData.type = 'pdf';
            proxyObject.userData.velocity = new THREE.Vector3();
            return { pdfCSSObject: cssObject, pdfProxyObject: proxyObject };
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            webglRenderer.setSize(window.innerWidth, window.innerHeight);
            cssRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            if (event.key === "Escape" && (isFocused || isTransitioning)) {
                exitFocusMode();
                return;
            }

            if (isFocused && !isTransitioning) {
                let moveDir = null;
                switch (event.code) {
                    case 'ArrowRight': moveDir = new THREE.Vector3(1, 0, 0); break;
                    case 'ArrowLeft':  moveDir = new THREE.Vector3(-1, 0, 0); break;
                    case 'ArrowUp':    moveDir = new THREE.Vector3(0, 1, 0); break;
                    case 'ArrowDown':  moveDir = new THREE.Vector3(0, -1, 0); break;
                }
                if (moveDir) {
                    event.preventDefault();
                    navigateToNearestPanel(moveDir);
                    return;
                }
            }

            if ((event.key === 'Delete' || event.key === 'Backspace') && selectedObject) {
                event.preventDefault();
                deleteObject(selectedObject);
            }

            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'KeyZ': moveUp = true; break;
                case 'KeyX': moveDown = true; break;
                case 'KeyQ': rotateLeft = true; break;
                case 'KeyE': rotateRight = true; break;
            }
            if (moveForward || moveBackward || moveLeft || moveRight) {
                exitFocusMode();
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'KeyZ': moveUp = false; break;
                case 'KeyX': moveDown = false; break;
                case 'KeyQ': rotateLeft = false; break;
                case 'KeyE': rotateRight = false; break;
            }
        }

        function navigateToNearestPanel(localDirection) {
            if (!focusedObject || isTransitioning || !localDirection) return;

            const worldDir = localDirection.clone().applyQuaternion(camera.quaternion).normalize();
            let nearest = null;
            let minDistance = Infinity;
            const angleThreshold = 0.5; 

            draggableObjects.forEach(obj => {
                if (obj === focusedObject || !obj.position) return;

                const toCandidate = new THREE.Vector3().subVectors(obj.position, focusedObject.position);
                const distance = toCandidate.length();
                toCandidate.normalize();
                
                const alignment = toCandidate.dot(worldDir);

                if (alignment > angleThreshold && distance < minDistance) {
                    minDistance = distance;
                    nearest = obj;
                }
            });

            if (nearest) {
                if (focusedObject.userData && focusedObject.userData.cssObject && focusedObject.userData.cssObject.userData.contentElement) {
                    focusedObject.userData.cssObject.userData.contentElement.style.pointerEvents = 'none';
                }
                enterFocusMode(nearest);
            }
        }
        
        function selectObject(object) {
            if (selectedObject && selectedObject.userData.cssObject) {
                selectedObject.userData.cssObject.element.classList.remove('selected');
            }
            selectedObject = object;
            if (selectedObject && selectedObject.userData.cssObject) {
                selectedObject.userData.cssObject.element.classList.add('selected');
            }
        }

        function deleteObject(objectToDelete) {
            scene.remove(objectToDelete);
            if (objectToDelete.userData.cssObject) {
                scene.remove(objectToDelete.userData.cssObject);
            }
            draggableObjects = draggableObjects.filter(obj => obj !== objectToDelete);
            contentPanels = contentPanels.filter(obj => obj !== objectToDelete && (!obj.userData || obj.userData.proxyObject !== objectToDelete));
            selectObject(null);
        }
        
        function onMouseDown(event) {
            if(event.target.closest('.hud-btn') || event.target.closest('.modal') || event.target.closest('.joystick-container')) return;
            const time = new Date().getTime();
            const isDoubleClick = time - lastClickTime < 300;
            lastClickTime = time;
            if(isDoubleClick) {
                handleDoubleClick();
                return;
            }
            previousMousePosition = { x: event.clientX, y: event.clientY };
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(draggableObjects);
            if (intersects.length > 0 && !isFocused) {
                isObjectDragging = true;
                draggedObject = intersects[0].object;
                selectObject(draggedObject);
                draggedObject.userData.velocity.set(0, 0, 0);
                dragPlane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(dragPlane.normal), draggedObject.position);
                const intersectionPoint = new THREE.Vector3();
                if (raycaster.ray.intersectPlane(dragPlane, intersectionPoint)) {
                    offset.copy(intersectionPoint).sub(draggedObject.position);
                }
                blocker.style.pointerEvents = 'auto';
            } else {
                 if (!isFocused) {
                    isCameraDragging = true;
                    blocker.style.pointerEvents = 'auto';
                }
                selectObject(null);
            }
        }

        function handleDoubleClick() {
            if (isTransitioning) return;

            if (isFocused) {
                exitFocusMode();
                blocker.style.pointerEvents = 'none';
                return;
            }

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(draggableObjects);
            
            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                
                if(clickedObject.userData.type === '360') {
                    enter360Mode(clickedObject);
                    return;
                }
                
                if (['text', 'image', 'video', 'localVideo', 'pdf', 'web', 'html'].includes(clickedObject.userData.type)) {
                    enterFocusMode(clickedObject);
                }
            }
        }

        function enterFocusMode(object) {
            isTransitioning = true;
            isFocused = true;
            focusedObject = object;
            lastCameraPosition.copy(camera.position);
            lastCameraQuaternion.copy(camera.quaternion);
            
            if (focusedObject.userData.cssObject && focusedObject.userData.cssObject.userData.contentElement) {
                focusedObject.userData.cssObject.userData.contentElement.style.pointerEvents = 'auto';
            }

            contentPanels.forEach(obj => {
                const isCurrentFocused = (obj === focusedObject || (obj.userData && obj.userData.proxyObject === focusedObject) || (focusedObject.userData && focusedObject.userData.cssObject === obj));

                if (!isCurrentFocused) {
                    if (obj.element) {
                        obj.element.style.display = 'none';
                    }
                    obj.visible = false;
                } else {
                    if (obj.element) {
                        obj.element.style.display = 'block';
                    }
                    obj.visible = true;
                }
            blocker.style.pointerEvents = 'none';
            });
        }
        
        function enter360Mode(sphere) {
            isTransitioning = true;
            isFocused = true;
            focusedObject = sphere;
            lastCameraPosition.copy(camera.position);
            sphere.scale.set(1, 1, 1);
            if (sphere.userData.isYouTube) {
            } else if (sphere.userData.video) {
                sphere.userData.video.muted = false;
            }
        }

        function exitFocusMode() {
            if (!isFocused) return;
            
            if (focusedObject && focusedObject.userData.cssObject && focusedObject.userData.cssObject.userData.contentElement) {
                focusedObject.userData.cssObject.userData.contentElement.style.pointerEvents = 'none';
            }

            isTransitioning = true;
            isFocused = false;
            
            contentPanels.forEach(obj => {
                if (obj.element) {
                    obj.element.style.display = 'block';
                }
                obj.visible = true;
            });
        }

        function onMouseUp(event) {
            isCameraDragging = false;
            isObjectDragging = false;
            draggedObject = null;
            blocker.style.pointerEvents = 'none';
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            if (isObjectDragging && draggedObject) {
                raycaster.setFromCamera(mouse, camera);
                const intersectionPoint = new THREE.Vector3();
                if (raycaster.ray.intersectPlane(dragPlane, intersectionPoint)) {
                    const newPosition = intersectionPoint.sub(offset);
                    draggedObject.position.copy(newPosition);
                    if (draggedObject.userData.cssObject) {
                        draggedObject.userData.cssObject.position.copy(newPosition);
                    }
                }
            } else if (isCameraDragging) {
                exitFocusMode();
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;
                yawAngle -= deltaX * mouseSensitivity;
                pitchAngle -= deltaY * mouseSensitivity;
                pitchAngle = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitchAngle));
            }
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }
        
        function onMouseWheel(event) {
            if (!isFocused && !isTransitioning) {
                zoomDistance -= event.deltaY * 0.02;
                zoomDistance = Math.max(5, Math.min(100, zoomDistance));
            }
        }

        function saveSceneToFile() {
            const data = serializeScene();
            const jsonString = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'chamalnquimyst-scene.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function loadSceneFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const sceneData = JSON.parse(e.target.result);
                    clearScene();
                    buildSceneFromData(sceneData);
                } catch (error) {
                    alert("Error al cargar el archivo.");
                    console.error(error);
                }
            };
            reader.readAsText(file);
        }

        function clearScene() {
            [...draggableObjects].forEach(obj => {
                if (obj.userData.cssObject) {
                    scene.remove(obj.userData.cssObject);
                }
                scene.remove(obj);
            });
            draggableObjects = [];
            contentPanels = [];
        }

        function buildSceneFromData(data) {
            data.forEach(item => {
                const pos = new THREE.Vector3().fromArray(item.position);
                switch (item.type) {
                    case 'text':
                        addTextPanelToScene(item.title, item.content, pos, item.color);
                        break;
                    case 'image':
                        addImagePanelToScene(item.src, pos, item.color);
                        break;
                    case 'video':
                        addVideoPanelToScene(item.videoId, 0, pos);
                        break;
                    case 'web':
                        addWebPanelToScene(item.url, pos);
                        break;
                    case 'html':
                        addHtmlPanelToScene(item.content, pos);
                        break;
                    case 'localVideo':
                        addLocalVideoPanelToScene(item.src, pos);
                        break;
                    case 'pdf':
                        addPdfPanelToScene(item.src, pos);
                        break;
                    case '360':
                        if (item.isYouTube) {
                            create360Bubble(item.src, pos, false, true);
                        } else {
                            create360Bubble(item.src, pos, true); 
                        }
                        break;
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            
            updateVideoLOD();

            // APLICAR INPUT DE JOYSTICKS TÁCTILES
            if (!isFocused && !isTransitioning) {
                const joystickMoveThreshold = 0.15;
                
                if (Math.abs(joystickLeftValue.y) > joystickMoveThreshold || Math.abs(joystickLeftValue.x) > joystickMoveThreshold) {
                    const speed = 10 * delta;
                    const direction = new THREE.Vector3();
                    camera.getWorldDirection(direction);
                    const right = new THREE.Vector3().crossVectors(camera.up, direction).normalize();
                    
                    // Adelante/Atrás (Y negativo = adelante)
                    if (joystickLeftValue.y < -joystickMoveThreshold) {
                        avatarObject.position.addScaledVector(direction, speed * Math.abs(joystickLeftValue.y));
                    } else if (joystickLeftValue.y > joystickMoveThreshold) {
                        avatarObject.position.addScaledVector(direction, -speed * joystickLeftValue.y);
                    }
                    
                    // Izquierda/Derecha
                    if (joystickLeftValue.x < -joystickMoveThreshold) {
                        avatarObject.position.addScaledVector(right, -speed * Math.abs(joystickLeftValue.x));
                    } else if (joystickLeftValue.x > joystickMoveThreshold) {
                        avatarObject.position.addScaledVector(right, speed * joystickLeftValue.x);
                    }
                }
                
                const joystickCameraThreshold = 0.15;
                
                if (Math.abs(joystickRightValue.y) > joystickCameraThreshold || Math.abs(joystickRightValue.x) > joystickCameraThreshold) {
                    const speed = 10 * delta;
                    
                    // Subir/Bajar (Y negativo = subir)
                    if (joystickRightValue.y < -joystickCameraThreshold) {
                        avatarObject.position.y += speed * Math.abs(joystickRightValue.y);
                    } else if (joystickRightValue.y > joystickCameraThreshold) {
                        avatarObject.position.y -= speed * joystickRightValue.y;
                    }
                    
                    // Rotación izquierda/derecha
                    if (joystickRightValue.x < -joystickCameraThreshold) {
                        yawAngle += cameraRotationSpeed * Math.abs(joystickRightValue.x) * delta * 60;
                    } else if (joystickRightValue.x > joystickCameraThreshold) {
                        yawAngle -= cameraRotationSpeed * joystickRightValue.x * delta * 60;
                    }
                }
            }

            if (!isFocused && !isTransitioning) {
                if (rotateLeft) yawAngle += cameraRotationSpeed * delta * 60;
                if (rotateRight) yawAngle -= cameraRotationSpeed * delta * 60;

                const speed = 10 * delta;
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);

                const right = new THREE.Vector3().crossVectors(camera.up, direction).normalize();

                if (moveForward) avatarObject.position.addScaledVector(direction, speed);
                if (moveBackward) avatarObject.position.addScaledVector(direction, -speed);
                if (moveLeft) avatarObject.position.addScaledVector(right, -speed);
                if (moveRight) avatarObject.position.addScaledVector(right, speed);
                if (moveUp) avatarObject.position.y += speed;
                if (moveDown) avatarObject.position.y -= speed;
                
                const targetQuaternion = new THREE.Quaternion().setFromEuler(new THREE.Euler(pitchAngle, yawAngle, 0, 'YXZ'));
                avatarObject.quaternion.slerp(targetQuaternion, 0.1);
                
                const offsetVec = new THREE.Vector3(0, 0, zoomDistance);
                offsetVec.applyQuaternion(avatarObject.quaternion);
                camera.position.copy(avatarObject.position).add(offsetVec);
                camera.lookAt(avatarObject.position);
            } else if (isTransitioning) {
                if (!focusedObject && isFocused) {
                    isTransitioning = false;
                    return;
                }

                let targetPosition = new THREE.Vector3();
                let targetQuaternion = new THREE.Quaternion();

                if (isFocused && focusedObject.userData.type === '360') {
                    targetPosition.copy(focusedObject.position);
                    targetQuaternion.copy(camera.quaternion);
                } else if (isFocused) {
                    focusedObject.getWorldPosition(targetPosition);
                    
                    const panelHeight = (focusedObject.geometry && focusedObject.geometry.parameters) ? 
                                        focusedObject.geometry.parameters.height : 8;
                    
                    const focusDistance = (panelHeight / 2) / Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
                    const direction = new THREE.Vector3();
                    focusedObject.getWorldDirection(direction);
                    targetPosition.addScaledVector(direction, focusDistance * 1.25);
                    
                    const tempMatrix = new THREE.Matrix4();
                    tempMatrix.lookAt(targetPosition, focusedObject.position, camera.up);
                    targetQuaternion.setFromRotationMatrix(tempMatrix);
                } else {
                    targetPosition.copy(lastCameraPosition);
                    targetQuaternion.setFromEuler(new THREE.Euler(pitchAngle, yawAngle, 0, 'YXZ'));
                }

                if (targetPosition && typeof targetPosition.x !== 'undefined') {
                    camera.position.lerp(targetPosition, 0.05);
                    
                    if (isFocused && focusedObject.userData.type !== '360') {
                        camera.quaternion.slerp(targetQuaternion, 0.05);
                    }

                    if (camera.position.distanceTo(targetPosition) < 0.1) {
                        isTransitioning = false;
                        if (!isFocused) {
                            focusedObject = null;
                            blocker.style.pointerEvents = 'none';
                        } else if (focusedObject.userData.type === '360') {
                            avatarObject.position.copy(targetPosition);
                        }
                    }
                }
            } else if (isFocused && focusedObject.userData.type === '360') {
                if (rotateLeft) yawAngle += cameraRotationSpeed * delta * 60;
                if (rotateRight) yawAngle -= cameraRotationSpeed * delta * 60;
                
                camera.position.copy(focusedObject.position);
                const targetLook = new THREE.Vector3(
                    focusedObject.position.x - Math.sin(yawAngle),
                    focusedObject.position.y,
                    focusedObject.position.z - Math.cos(yawAngle)
                );
                camera.lookAt(targetLook);
            }
            
            camera.updateProjectionMatrix();

            draggableObjects.forEach(obj => {
                if (obj.userData.velocity && obj.userData.velocity.lengthSq() > 0.0001) {
                    obj.position.add(obj.userData.velocity);
                    obj.userData.velocity.multiplyScalar(0.95);
                    if (obj.userData.cssObject) {
                        obj.userData.cssObject.position.copy(obj.position);
                    }
                }
            });

            if(viewMode === 'lookAtCamera') {
                draggableObjects.forEach(panel => {
                    if (panel.userData.type !== '360') {
                        panel.lookAt(camera.position);
                        if (panel.userData.cssObject) {
                            panel.userData.cssObject.quaternion.copy(panel.quaternion);
                        }
                    }
                });
            }

            webglRenderer.render(scene, camera);
            cssRenderer.render(scene, camera);
        }
        function addTextPanelToScene(title, content, position, color) {
            const div = document.createElement('div');
            div.className = 'text-panel content-panel-wrapper';
            div.style.borderColor = color;
            div.style.boxShadow = `0 0 30px ${color}`;
            div.innerHTML = `
                <div class="text-panel-title" style="color:${color}">${title}</div>
                <div class="text-panel-content">${content}</div>
            `;

            const cssObject = new THREE.CSS3DObject(div);
            cssObject.position.copy(position);
            cssObject.scale.set(0.01, 0.01, 0.01);
            
            // Crear el objeto invisible para que el Raycaster pueda detectarlo
            const geometry = new THREE.PlaneGeometry(800 * 0.01, 600 * 0.01);
            const material = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            
            mesh.userData = { type: 'text', title, content, color, cssObject, velocity: new THREE.Vector3() };
            scene.add(cssObject);
            scene.add(mesh);
            draggableObjects.push(mesh);
        }

        function addVideoPanelToScene(videoId, startTime, position) {
            const div = document.createElement('div');
            div.className = 'video-panel content-panel-wrapper';
            div.innerHTML = `<iframe src="https://www.youtube.com/embed/${videoId}?autoplay=0" allowfullscreen></iframe>`;

            const cssObject = new THREE.CSS3DObject(div);
            cssObject.position.copy(position);
            cssObject.scale.set(0.01, 0.01, 0.01);
            cssObject.userData = { videoId };

            const geometry = new THREE.PlaneGeometry(1280 * 0.01, 720 * 0.01);
            const mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
            mesh.position.copy(position);
            mesh.userData = { type: 'video', cssObject, velocity: new THREE.Vector3() };

            scene.add(cssObject);
            scene.add(mesh);
            draggableObjects.push(mesh);
        }
        // --- FUNCIONES DE CONSTRUCCIÓN FALTANTES ---

        function addImagePanelToScene(src, position, color = '#4DDBFF') {
            const loader = new THREE.TextureLoader();
            loader.load(src, (texture) => {
                const aspect = texture.image.width / texture.image.height;
                const width = 10;
                const height = width / aspect;

                const geometry = new THREE.PlaneGeometry(width, height);
                const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(position);

                // Añadir un borde brillante
                const borderGeo = new THREE.BoxLineGeometry(width + 0.1, height + 0.1, 0.1, 1, 1, 1);
                const borderMat = new THREE.LineBasicMaterial({ color: color });
                const border = new THREE.LineSegments(borderGeo, borderMat);
                mesh.add(border);

                mesh.userData = { 
                    type: 'image', 
                    src: src, 
                    color: color,
                    velocity: new THREE.Vector3() 
                };

                scene.add(mesh);
                draggableObjects.push(mesh);
                contentPanels.push(mesh);
            });
        }

        function addWebPanelToScene(url, position) {
            const div = document.createElement('div');
            div.className = 'web-panel content-panel-wrapper';
            div.innerHTML = `<iframe src="${url}"></iframe>`;

            const cssObject = new THREE.CSS3DObject(div);
            cssObject.position.copy(position);
            cssObject.scale.set(0.01, 0.01, 0.01);
            
            // El objeto iframe necesita que activemos los eventos manualmente en foco
            cssObject.userData = { url: url, contentElement: div.querySelector('iframe') };

            const geometry = new THREE.PlaneGeometry(12.8, 7.2); // Proporción 1280x720
            const material = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);

            mesh.userData = { 
                type: 'web', 
                cssObject: cssObject, 
                velocity: new THREE.Vector3() 
            };

            scene.add(cssObject);
            scene.add(mesh);
            draggableObjects.push(mesh);
            contentPanels.push(mesh);
        }
    </script>
</body>
</html>
